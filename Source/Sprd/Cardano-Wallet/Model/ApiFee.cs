/* 
 * Cardano Wallet Backend API
 *
 * <p align=\"right\"><img style=\"position: relative; top: -10em; margin-bottom: -12em;\" width=\"20%\" src=\"https://cardanodocs.com/img/cardano.png\"></img></p> 
 *
 * OpenAPI spec version: 2021.2.15
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = IO.Swagger.Client.SwaggerDateConverter;

namespace IO.Swagger.Model
{
    /// <summary>
    /// ApiFee
    /// </summary>
    [DataContract]
        public partial class ApiFee :  IEquatable<ApiFee>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ApiFee" /> class.
        /// </summary>
        /// <param name="estimatedMin">estimatedMin (required).</param>
        /// <param name="estimatedMax">estimatedMax (required).</param>
        /// <param name="minimumCoins">A list of minimum coin values that each output in a payment must satisfy. The values themselves depends on two things:    - (a) Some updatable protocol parameters fixed by the network.   - (b) The nature of the outputs (i.e. the kind of assets it includes).  The list is a direct 1:1 mapping of the requested outputs. Said differently, it has the **same number of items** and **items are ordered in the same way** as **requested outputs** are ordered. In the case where there&#x27;s no explicitly requested outputs (e.g. when calculating fee for delegation), this list is empty.  For example, an output containing only &#x60;Ada&#x60; may require to be of at least &#x60;1 Ada&#x60;. An output containing only an hypothetical &#x60;AppleCoin&#x60; may require to also carry a minimum of &#x60;1.2 Ada&#x60;. Note that no matter what, a minimum coin value is always given in Lovelace / Ada.  &gt; ℹ️ This mechanism is used by the protocol to protect against flooding of the network with worthless assets. By requiring a minimum coin value to every UTxO, they are given an intrinsic value indexed itself on the value of Ada.  (required).</param>
        /// <param name="deposit">deposit (required).</param>
        public ApiFee(WalletswalletIdpaymentfeesAmount estimatedMin = default(WalletswalletIdpaymentfeesAmount), WalletswalletIdpaymentfeesAmount estimatedMax = default(WalletswalletIdpaymentfeesAmount), List<WalletswalletIdpaymentfeesAmount> minimumCoins = default(List<WalletswalletIdpaymentfeesAmount>), WalletswalletIdpaymentfeesAmount deposit = default(WalletswalletIdpaymentfeesAmount))
        {
            // to ensure "estimatedMin" is required (not null)
            if (estimatedMin == null)
            {
                throw new InvalidDataException("estimatedMin is a required property for ApiFee and cannot be null");
            }
            else
            {
                this.EstimatedMin = estimatedMin;
            }
            // to ensure "estimatedMax" is required (not null)
            if (estimatedMax == null)
            {
                throw new InvalidDataException("estimatedMax is a required property for ApiFee and cannot be null");
            }
            else
            {
                this.EstimatedMax = estimatedMax;
            }
            // to ensure "minimumCoins" is required (not null)
            if (minimumCoins == null)
            {
                throw new InvalidDataException("minimumCoins is a required property for ApiFee and cannot be null");
            }
            else
            {
                this.MinimumCoins = minimumCoins;
            }
            // to ensure "deposit" is required (not null)
            if (deposit == null)
            {
                throw new InvalidDataException("deposit is a required property for ApiFee and cannot be null");
            }
            else
            {
                this.Deposit = deposit;
            }
        }
        
        /// <summary>
        /// Gets or Sets EstimatedMin
        /// </summary>
        [DataMember(Name="estimated_min", EmitDefaultValue=false)]
        public WalletswalletIdpaymentfeesAmount EstimatedMin { get; set; }

        /// <summary>
        /// Gets or Sets EstimatedMax
        /// </summary>
        [DataMember(Name="estimated_max", EmitDefaultValue=false)]
        public WalletswalletIdpaymentfeesAmount EstimatedMax { get; set; }

        /// <summary>
        /// A list of minimum coin values that each output in a payment must satisfy. The values themselves depends on two things:    - (a) Some updatable protocol parameters fixed by the network.   - (b) The nature of the outputs (i.e. the kind of assets it includes).  The list is a direct 1:1 mapping of the requested outputs. Said differently, it has the **same number of items** and **items are ordered in the same way** as **requested outputs** are ordered. In the case where there&#x27;s no explicitly requested outputs (e.g. when calculating fee for delegation), this list is empty.  For example, an output containing only &#x60;Ada&#x60; may require to be of at least &#x60;1 Ada&#x60;. An output containing only an hypothetical &#x60;AppleCoin&#x60; may require to also carry a minimum of &#x60;1.2 Ada&#x60;. Note that no matter what, a minimum coin value is always given in Lovelace / Ada.  &gt; ℹ️ This mechanism is used by the protocol to protect against flooding of the network with worthless assets. By requiring a minimum coin value to every UTxO, they are given an intrinsic value indexed itself on the value of Ada. 
        /// </summary>
        /// <value>A list of minimum coin values that each output in a payment must satisfy. The values themselves depends on two things:    - (a) Some updatable protocol parameters fixed by the network.   - (b) The nature of the outputs (i.e. the kind of assets it includes).  The list is a direct 1:1 mapping of the requested outputs. Said differently, it has the **same number of items** and **items are ordered in the same way** as **requested outputs** are ordered. In the case where there&#x27;s no explicitly requested outputs (e.g. when calculating fee for delegation), this list is empty.  For example, an output containing only &#x60;Ada&#x60; may require to be of at least &#x60;1 Ada&#x60;. An output containing only an hypothetical &#x60;AppleCoin&#x60; may require to also carry a minimum of &#x60;1.2 Ada&#x60;. Note that no matter what, a minimum coin value is always given in Lovelace / Ada.  &gt; ℹ️ This mechanism is used by the protocol to protect against flooding of the network with worthless assets. By requiring a minimum coin value to every UTxO, they are given an intrinsic value indexed itself on the value of Ada. </value>
        [DataMember(Name="minimum_coins", EmitDefaultValue=false)]
        public List<WalletswalletIdpaymentfeesAmount> MinimumCoins { get; set; }

        /// <summary>
        /// Gets or Sets Deposit
        /// </summary>
        [DataMember(Name="deposit", EmitDefaultValue=false)]
        public WalletswalletIdpaymentfeesAmount Deposit { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class ApiFee {\n");
            sb.Append("  EstimatedMin: ").Append(EstimatedMin).Append("\n");
            sb.Append("  EstimatedMax: ").Append(EstimatedMax).Append("\n");
            sb.Append("  MinimumCoins: ").Append(MinimumCoins).Append("\n");
            sb.Append("  Deposit: ").Append(Deposit).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ApiFee);
        }

        /// <summary>
        /// Returns true if ApiFee instances are equal
        /// </summary>
        /// <param name="input">Instance of ApiFee to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ApiFee input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.EstimatedMin == input.EstimatedMin ||
                    (this.EstimatedMin != null &&
                    this.EstimatedMin.Equals(input.EstimatedMin))
                ) && 
                (
                    this.EstimatedMax == input.EstimatedMax ||
                    (this.EstimatedMax != null &&
                    this.EstimatedMax.Equals(input.EstimatedMax))
                ) && 
                (
                    this.MinimumCoins == input.MinimumCoins ||
                    this.MinimumCoins != null &&
                    input.MinimumCoins != null &&
                    this.MinimumCoins.SequenceEqual(input.MinimumCoins)
                ) && 
                (
                    this.Deposit == input.Deposit ||
                    (this.Deposit != null &&
                    this.Deposit.Equals(input.Deposit))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.EstimatedMin != null)
                    hashCode = hashCode * 59 + this.EstimatedMin.GetHashCode();
                if (this.EstimatedMax != null)
                    hashCode = hashCode * 59 + this.EstimatedMax.GetHashCode();
                if (this.MinimumCoins != null)
                    hashCode = hashCode * 59 + this.MinimumCoins.GetHashCode();
                if (this.Deposit != null)
                    hashCode = hashCode * 59 + this.Deposit.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
